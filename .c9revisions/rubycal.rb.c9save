{"ts":1349984237857,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#Events will be added to each day that they occur on, but will also keep track of the position which the main Calendar object will set\n#Position will be the Event's position in the stack of events for that day(i.e)\n#                 1        2        3      4       5       \n#                 e1       e1       e1             e2\n#                          e3       e3\n#------------------------------------------------------\n#6       7        8        9       10      11\n#e4      e4       e4       e4      e4      e4\n#        e5       e5       e5      e6      e6\n#------------------------------------------------------\n#In this example, e1's pos would be 0 for day's 1,2, and 3.\n#e5's pos would be 1 for day's 7,8, and 9.\n\nclass Calendar\n\n  attr_reader :days\n  \n  SATURDAY = 6\n  SUNDAY   = 0\n  \n  def initialize(options={})\n    @weeks = []\n    @number_of_weeks = 0\n    @number_of_events = 0\n    @events = []\n    @month = options[:month]\n    @year  = options[:year]\n    @ouput = ''\n    build_calendar(@year,@month) if @month && @year\n    yield(self) if block_given?\n  end\n  \n  #Month of calendar year and month\n  def build_calendar(y,m)\n    @month,@year = m.to_i,y.to_i\n    first = Date.new(@year,@month,1)\n    last = Date.new(@year,@month,-1)\n    n = last.day \n    s = first.wday\n    build_days_and_weeks(s,n)\n  end\n  \n  #s(day of the week to start on zero(Sunday) - six(Saturday))\n  #n(number of days in the month)\n  def build_days_and_weeks(s,n)\n    new_day = ''\n    1.upto(n) do |day|\n      new_day = Day.new(day,@number_of_weeks,s,@month,@year)\n      if day == 1 || s == SUNDAY #first day of week\n        @weeks << Week.new(new_day.date,s)\n      end\n      @weeks.last.add_day(new_day)\n      if s == SATURDAY\n        s = SUNDAY\n        @weeks.last.end_date = new_day.date\n        @number_of_weeks += 1\n      else\n        s += 1\n      end\n    end\n    @weeks.last.end_date = new_day.date\n  end\n  \n  def add_days_at_start_of_month(first_day)\n    0.upto(first_day.day_of_week-1) {@days.first.unshift('X')}\n  end\n  \n  def add_days_to_end_of_month(last_day)\n    (last_day.day_of_week+1).upto(SATURDAY) {@days.last.push('X')}\n  end\n  \n  def <<(event)\n    @number_of_events += 1\n    #You can use Caledar::Event for testing outside of rails\n    @events << event\n    #@events << Event.new(@number_of_events,event[:title],event[:start],event[:end])\n  end\n  \n  def add_events(events)\n    @events.concat(events)\n  end\n  \n  def generate\n    for event in @events\n      for week in @weeks\n        week << event if event.within?(week.start_date,week.end_date)\n      end\n    end\n    for week in @weeks\n      week.sort_events!\n    end\n  end\n  \n  def pp\n    for week in @weeks\n      #puts week.to_s\n\t\t\tputs \"-\" * 120\n      for day in week.days\n        row = %{#{day.day_of_month.to_s.rjust(2)} X }\n        row += day.events.inject([]) do |acc,event|\n          if event.nil?\n            acc << \"-\" * 34\n          else\n            acc << \"(#{event})\"\n          end \n          acc\n        end.join(' X ')\n        puts row\n      end\n    end\n  end \n\t\n\tdef html_for_event\n\t  generate\n\t  \n\t  out = '<table style=\"width:100%\" class=\"calendar\">'\n\t\theight = 'height:20px;'\n\t\tstyle_one = 'background:#fff;color:#000;'\n\t\tstyle_two = 'background:#000;color:#fff;'\n\t\tout << %{<tr>}\n\t\tfor day in Date::DAYNAMES\n\t\t  out << %{<th>#{day}</th>}\n\t\tend\n\t\tout << %{</tr>}\n    for week in @weeks\n\t\t  out << %{<tr valign=\"top\">}\n\t\t\tout << %{<td>&nbsp;</td>} * week.first_day_of_week\n      for day in week.days\n        out << %{<td>}\n\t\t\t\tout << %{<div style=\"#{height}\">#{day.day_of_month}</div>}\n\t\t\t\tposition_level = 0\n        out << day.events.inject('') do |acc,event|\n\t\t\t\t  style = position_level % 2 == 0? style_one : style_two\n          if event.nil?\n            acc << %{<div style=\"#{style}\" class=\"day\">&nbsp;</div>}\n          else\n            acc <<  %{<div style=\"#{style}\" class=\"day\">#{yield(event)}</div>}\n          end \n\t\t\t\t\tposition_level += 1\n          acc\n        end\n\t\t\t\tout << %{</td>}\n      end\n\t\t\tout << %{</tr>}\n    end\n\t\tout << %{</table>}\n\t\t@output = out\n\tend\n\t\n\tdef to_s\n\t  @output\n\tend\n  \n  class Week\n    \n    attr_accessor :start_date, :end_date,:days,:first_day_of_week\n    def initialize(s,dow)\n      @start_date = s\n\t\t\t@first_day_of_week = dow\n      @days = []\n      @events = []\n    end\n    \n    def <<(event)\n      @events << event\n      @events.last.nodoiw = event.days_within?(@start_date,@end_date)\n    end\n    \n    def add_day(day)\n      @days << day\n    end\n    \n    def to_s\n      events = @events.sort_by {|e| e.nodoiw }.reverse.map {|e| \"#{e.id}x#{e.nodoiw}\"}.join(' ')\n      \"Week(#{@start_date} - #{@end_date}:events#{events})\"\n    end\n    \n\t\t#Could be made faster by just assigning to positions if pos is equal zero or position \n    def sort_events!\n      position = 0\n      @events.sort_by {|e| e.nodoiw }.reverse.each do |event|\n\t\t\t\t(0..position).each do |pos|\n\t\t\t\t\tif positions_for_days_are_available?(event,pos)\n\t\t\t\t\t\tassign_events_to_days(event,pos)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n        position += 1\n      end\n    end\n\t\t\n\t\tprivate\n\t\t\n\t\t  def assign_events_to_days(event,position)\n\t\t\t  @days.each do |day|\n          day.add_event(event,position) if event.within?(day.date,day.date)\n\t\t\t\tend\n      end\n\t\t\t\n\t\t\tdef positions_for_days_are_available?(event,position)\n\t\t\t  for day in @days\n\t\t\t\t  if event.within?(day.date,day.date) && !day.position_is_available?(position)\n\t\t\t\t\t  return false\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\treturn true\n\t\t\tend\n  end\n  \n  class Day\n    attr_reader :day_of_month,:week_of_month,:day_of_week,:year,:date\n    attr_reader :events\n    \n    def initialize(n,w,d,m,y)\n      @date = Date.new(y,m,n)\n      @day_of_month = n\n      @week_of_month = w\n      @day_of_week = d\n      @year = y\n      @events = []\n    end\n    \n    def add_event(event,position)\n      @events[position] = event\n    end\n\t\t\n\t\tdef position_is_available?(position)\n\t\t  ! @events[position]\n\t\tend\n    \n    def to_s\n      \"Day(day#{@day_of_month}/#{@year}:dow#{@day_of_week}:wom#{@week_of_month}:events#{@events.size})\"\n    end\n  end\n  \n  class Event\n    attr_reader :id,:title,:start_date,:end_date\n    attr_accessor :nodoiw\n    \n    def initialize(id,t,s,e)\n      @id = id\n      @title = t\n      @start_date = Date.parse(s.to_s)\n      @end_date = Date.parse(e.to_s)\n    end\n    \n    def to_s\n      \"Event(#{@id}:#{@start_date} - #{@end_date})\"\n    end\n    \n    def within?(s,e)\n      (@start_date <= e) && (@end_date >= s)\n    end\n    \n    def days_within?(s,e)\n      (s..e).inject(0) do |days,day| \n        days += 1 if within?(day,day)  \n        days\n      end\n    end\n  end\nend\n"]],"start1":0,"start2":0,"length1":0,"length2":6569}]],"length":6569}
{"contributors":[],"silentsave":false,"ts":1349984267245,"patch":[[{"diffs":[[0,"and 9.\n\n"],[1,"#Cloud Nine Test\n\n"],[0,"class Ca"]],"start1":714,"start2":714,"length1":16,"length2":34}]],"length":6587,"saved":false}
